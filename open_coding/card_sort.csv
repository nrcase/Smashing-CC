anon#Easiness#Difficulties#Effectiveness
ncsu0#Some changes were just simple arithmetic and logical changes which was easy to fix#Some changes were long and difficult to understand what the changes were doing#looking with other people
ncsu1#Tools on github were easy to use and understand after taking 326#Tracing through lines of code and results in my head#I think we were given all necessary resources to complete the study effectively.
ncsu2#Some examples provide obvious evidence of inequality in code output, such as differing comparison checks.#Many changes in one file are hard to verify for every output.#Because most of the functions took integers as an input, a simple test with a range positive to negative input values would make this error checking a lot easier.
ncsu3#identifying the difference in different inputs.#nothing.#more comment on why those changes were made.
ncsu4#the code was not hard to follow #Reading code in unfamiliar classes #Documentation on the classes and methods 
ncsu5#identify the changes that were made#tracing through the changes and evaluate if the changes affect the code's behavior#performing code review with other colleagues
ncsu6#The GitHub helped in looking at the differences. #Sometimes I was overthinking which made the question more complicated. #I feel that it was good and no improvements needed
ncsu7#It was easy to map through some of the changes on the smaller files.#Understanding the code was somewhat complicated at times as I had to look at completely different code jumping all over the place without knowing exactly what it was intended to do.#Having an explanation of what the code was intended to do without having to infer it.
ncsu8#Picking out changes in logic for shorter snippets#Understanding whether changes that involved large blocks of text maintained equivalent functions. #If changes that were related were put side by side, with more spacing between lines
ncsu9#It was easy to see what the syntax changes between the original and the new code.#It was difficult to understand the meaning of the changes in context.#Knowing more about the program these changes would be implemented in would have helped.
ncsu10#Majority of it seemed correct #I did not really understand what was being done. #Easier code.
ncsu11#Spotting logical/behavioral differences#Having to review code that I had no context for. Although I did have access to the original entire code files that were being reviewed, having to trace code for something you have no context for can be a little difficult.#If I had more context for the methods that were being reviewed. However, this was not at all necessary.
ncsu12#Some of the statements that were simple modifications to conditionals were pretty easy to evaluate and understand, for instance where I was able to easily understand what the methods were doing and when i could apply mathematical rules to conditions#Some of the portions of code were rather unorganized and hard to follow, namely the TCAS.java file, this one was especially hard to follow and trace. #If the code were a little well more documented. For instance, providing a description of what each parameter in a function does would have made the review process easier
ncsu13#Some Boolean conditionals where just negations or combining conditionals together.#Doing a run through of the code when it involved various amount of math or recursion.#Having a peer help me review it with me.
ncsu14#It was easy to follow the instructions and i knew what had to be done#Nothing much, it was organized#More time for more detailed analysis
ncsu15#GitHub's diff view is very useful and makes it super easy to find small differences - which is what this was all about - very quickly.#Nothing, really - it was fairly easy.#There's not much to it - these changes were small, and GitHub's diff view took care of all the visual parts, which left the easy logic as the only task I had to do. Maybe if Generative AI was confirmed to be helpful guaranteed so I could automate it there? That would likely take long though, as would writing any scripts to automatically test it.
ncsu16#Sometimes the code is very simple and mathematical.#Sometimes the code is hard to parse and is messy#I would have appreciate more comments explaining why the changes were made so I could understand more.
ncsu17#Issues with less lines of code to analyze #Some were somewhat lengthy while others were very short and simple to trace#More comments on the code
ncsu18#The reviews were (mostly) only a couple of lines of code#Lack of documentation and general lack of familiarity with the code meant spending more time attempting to understand the flow of the code#Not sure
ncsu19#"the recursive function wasn't that bad (embarrassing if I got it wrong) because I like recursion. Functions where a value was ""deceptively"" changed were pretty easy."#The TCAS one that took functions of several variables was hard, the if-else trees were hard to parse.#I would have liked some guarantee that everything is syntactically valid. a = -a and the colon after the semicolon threw me for a loop and I had to check in my ide.
ncsu20#Helpful#Not much#It was perfect 
ncsu21#Some of the PR's had fairly simple code#The code was confusing at times#If I had more time to look things up
ncsu22#Using github to view the file changes.#Remembering refactoring.#A quick review on refactoring.
ncsu23#It was easy to make a comment and accept merges, and closing requests.#It was tough to not get overwhelmed when seeing many changes to many methods in one change.#It would have helped me to understand the purpose of a method instead of just seeing the functions within it.
ncsu24#The GitHub tools to view changes in parallel. #The TCAS was difficult to parse through to understand functionality. Not many comments/documentation throughout made it difficult.#Proper documentation on methods (code comments).
ncsu25#Smaller changes were fairly easy to parse for modifications. AI made larger changes easier to parse trough.#If changes were more extensive, it was harder to detect modifications to code behavior#If I could run the code locally to test it myself.
ncsu26#I think it was easy to find differences in codes that did not have intense math. #The most difficult part was determining what the functions were supposed to do. Performing intense math for some was also challenging. Inputs were not given so it was also hard to determine outputs given arbitrary numbers.#Documentation on any of the code would have helped. Knowing inputs would help too.
ncsu27#well written code#trying to figure what the entire the code was doing#having some comments in the code
ncsu28#Some code changes were minimal so they were easy to review.#Inexperience with code that was written and not seeing the full code in the PR.#More time to review and possibly consulting with the people who wrote the code. 
ncsu29#Some issues were easy to find and check#Doing it in my phone and the GitHub UI is a bit tougher to parse compared to the eclipse ui to check differences when committing#The ability to let generative ai check functionality for me
ncsu30#the GitHub features that highlight the changes made#reviewing The code where the first code is too cluttered and hard to understand#having the requirement and test cases
ncsu31#It was clear what code was changed thanks to GitHub.#Figuring out what the code was supposed to do.#More information about what the code is supposed to do.
ncsu32#Some of the code was easier to tell that there were no significant changes present.#It's hard not really being in the loop about what the code is supposed to be for, and it's easier when you can talk with the person and ask them about what they're trying to achieve.#Perhaps if I was able to easily run the different methods on my laptop with different variables.
ncsu33#when the changes were very apparent they popped out immediately#reading through some of the more complex code was difficult. I also was not able to run any of the code which made it more difficult#Being able to run the code.
ncsu34#It was easy to find the distinctive differences in code as we could compare the files on github and for some of the pull requests the behavior changes were clear.#It was a bit difficult being able to understand how to differentiate between when the overall behavior of the code changed or if there were just minor changes but the functionality of the code was the same.#I think a better understanding of the code/project being worked on or a general understanding of the project would also give us a better understanding of each of the behaviors of the files we are analyzing.
ncsu35#some pull requests hardly changed any code and it was simple to review#some of them had a lot of code to review#If there was less code to review in some of them
ncsu36#I get access to the entire source code.#to understand the entire context of the class and behavior. It's not just the changes made.#specify the requirements/expectations when it comes to code review. I wasn't inform about the quality of the comments such as: should I explain the changes that change the behavior completely or not, etc..
ncsu37#seeing if the new conditions were added or not which would result in modified behavior.#not knowing what the files were for as well as not knowing the purpose of some of the variables. #I believe enough details were provided to us in order to facilitate the study. Additionally, we were allowed to use online resources for syntax help as well as knowing the behavior of the code. 
ncsu38#UI on GitHub is clear to show 2 pieces of code#I didn't see all parts of the code#It looks good enough
ncsu39#Some changes were pretty obvious#Not having the full context of the code#unit tests or github actions
ncsu40#The instructions and the readme made it extremely easy to understand how to work on this task.#Some of the changes were a bit confusing as I didn't take a look through the entire codebase and I didn't know how it all worked.#Being given some more time before time to look through the codebase to get a better understanding of the code.
ncsu41#some of the easier pull requests with simple code was easy to walk through in my head. #To focus on the stuff and hand and actually understand what it is doing.#smaller code changes and code comments.
ncsu42#If statement comparisons#Doing math at 8 in the morning on Monday right before finals.#More coffee
ncsu43#It was easy to review if something was changed a lot, for example new variable was added#To understand what the code snippet was doing#Using other resources more
ncsu44#Some changes were clearly changing the behavior. If a different value was returned for example, that was clearly a change. If conditions for an if statement were moved into variables, and then the if statement was called with those variables, that was clearly not a change.#I wasn't entirely sure what constituted a change to the behavior. If additional computations and operations had to be performed, I wasn't certain if that was a change.#If I knew more about what constituted a change in behavior.
ncsu45#I felt confident in reading the files and being able to spot the differences. #Calculating if any of the math in the code review had the same output. #This code review might have been more effective at a different time of day where I was not so sleepy. 
ncsu46#Most files only had 1 or 2 changes#Lack of comments#Maybe had another person reviewing it with me to catch mistakes I may of made reviewing
ncsu47#The split view in GitHub made it easy to see the changes in the code from the original to the modified version.#The difficulty in performing the code review in this study is that there aren't any comments in the functions detailing what it is supposed to do and I don't have an overview of the flow between the various classes to fully understand how the changes in one file would affect other runs.#I would have been able to perform the code review in this study more effectively if there was a button on GitHub that allowed me to expand the file I was reviewing to see the entire file with the changes on top without having to open a separate window.
ncsu48#The easy part was knowing that the code behavior was ultimately changed if the return value was being altered i.e. if a + 10 was added to the return value and it wasn't there before.#The difficult part was going through what was being deleted and added in the Files Changed section of the Merge Review and coming up with a definitive answer of whether or not the code behavior has changed. #In the future, going through the code line-by-line before and after the changes and making sure that the logic and return values are the same would have helped me in this study.
ncsu49#Easily looking at changed code in GitHub is a pleasant experience.#A few files were long and complex to fully read through and get an understanding right away. Some were straight forward.#I think this flow of code review is easy to follow! Never did it this way before, and I approve of this newly learned flow.
ncsu50#The interface that github provides is quite convenient and makes it easy to conduct code review.#The most difficult part is to understand what the code does. Having to look at fresh code without idea of what it does can provide hardships when doing a code review to ensure the code has the same functionality. #If I understood each file on a more in-depth layer and provide better code review.
ncsu51#I think that the way it was explained when the class started made it very easy to perform the review.#I thought that it was very relaxing, and wasn't necessarily difficult.#I think I performed as effectively as I wanted. Perhaps if I took more time I could have been more in depth.
ncsu52#There were a few that were 1 or 2 line code changes.#I think it was moderately difficult.#I think if I had ran it in the IDE, it would have been easier.
ncsu53#Most of the code review was straight forward with direct differences making it very easy #Sometimes it was hard to scroll between the two codes to find the differences especially the one with all the conditions.#I think having more experience with general coding and being faster and finding the differences, but it was pretty easy 
ncsu54#Spotting major differences that stood out like a sore thumb.#Determining if the code performed the same functionality. Some of the code looked drastically different but seemed to still perform the same.#If I was able to easily test the changes. For example, unit tests that I could see passing or failing. Maybe a GitHub actions to show the changes.
ncsu55#It was easy when it was obvious that the code changes changed the functionality of the code. #When there were a lot of changes it was tough to track through all of them.#If I knew how to use more outside resources. 
ncsu56#"GitHub's diff view is great for diffs with small # of consecutive line changes (i.e. not rewriting a whole function)"#Some of the changes were bad for other reasons (style, performance, readability) that made it hard to check for correctness.#Unit tests to show that the behavior has or has not changed
ncsu57#Following the process of the code reviews was easy based on previous GitHub processes in this class.#I didn't realize it was open to resources so I was trying to perform code reviews by hand. This may have lead to mixed results, as I could have tried writing tests for this program instead of trying to do it by hand.#I should have written tests or consulted external resources when doing the code reviews.
ncsu58#understanding what the changes made would impact the code. #understanding what the code was supposed to do #having effective method names and description of changes and etc for each PR
ncsu59#Some of the pull requests were clearly going to cause functionality changes and some where clearly just refactoring.#There is always a lot of text in code, and it is always difficult to read everything and think of the different relationships and implications of a code change.#The easy answer would be if we were given the output or examples of the code actually running. This would clearly show us whether or not the functionality of the code changed.
ncsu60#Github process with closing and adding comments. #Trying to code trace backwards to see if any behavior had changed. #Knowing the intended purpose of the code before hand with comments maybe. But outside resources helped.
ncsu61#The ability to change views in Github and have changes highlighted in red and green made it much easier to tell what exactly had changed between versions.#Evaluating the results of functions, especially recursive ones, were more difficult without actually running the code. In addition, the longer more dense sections of code made it difficult to keep track of parameters and compare between versions.#Having the ability to focus on just a specific scope or block of code may have made it easier - sometimes it was difficult to tell where code was placed based on indentation alone, especially when longer sections of code were in different places between versions.
ncsu62#using generative ai#nothing#access to chatgpt4 turbo
ncsu63#The splitting of the files on github made it easier to compare changes#The code was poorly written.#If the code had better formatting.
ncsu64#I knew how to use github for code review and pull requests!#I wasn't entirely sure about all of the math functions, which is when i used online resources to see if the code changed or not (not that I'm sure any of them are right)#a more in depth knowledge of the code base / what it's aiming to do / access to testing software to make sure that the tests all passed the same when the code was refactored.
ncsu65#The split tab made it easier to review the code in this study as it was easier to see how the code differs in a side by side manner. Moreover, highlighting the lines that have been changed helped understand the changes that might affect the external behvaior of the program. #Not being able to see the entire code made it a little harder to gauge the purpose of the code.#I believe that removing the time constraint would have helped relieve the pressure and concentrate more on the code. 
ncsu66#Nothing it was fine#Nothing#Nothing 
ncsu67#Some of the tasks were familiar and could quickly be reviewed.#Code tracing was the most difficult portion. Longer control flows took more time and required maintaining a lot of program state.#If I had someone to collaborate with, the code review could have gone more smoothly. We could improve the odds that both of us have the correct understanding of the code.
ncsu68#Some of the refactors were simple and led to easy to find behavioral bugs #Some of the refactors were very dense and seemingly pointless#Maybe if I had used an IDE
ncsu69#Yes it was pretty easy#Nothing as such was difficult #Understanding the context of the code before
ncsu70#It was easy to see what changes were made and understand what these changes did.#I did not know the context behind the program, which makes it very difficult to determine whether the behavior of the code is changed or not, since it may expect different results.#Knowing context behind the code.
ncsu71#Once the logic was understood, explaining what needs to be changed and being able to either request changes or merge the changes was easy. #Understanding the logic of the code in such a small context and without debugging it in an IDE. #Being able to discuss with others or with the author of the code would helped me more. 
ncsu72#Easy (I think?) to tell when different math operations led to different behavior.#Unfamiliar with code base (i.e. did not know what the code was trying to achieve)#GenAI
ncsu73#The code was in a syntax that I could understand (Java).#The variable names were not descriptive enough and the code as a whole was not informative as to what it was supposed to do.#Better comments and variable naming.
ncsu74#Most of the reviews had fairly simple changes.#Not knowing what some of the functions did and how they would be used.#If we better understood what the code would be used for.
ncsu75#Some of the code changes were very apparent what they were doing and/or attempting to do.#Some of the code was convoluted and hard to understand what was going on.#Code comments
ncsu76#Some of the logic was simple math that was easier to dissect without having to look at the surrounding code. #Not being familiar with the code base and having the knowledge of the surrounding code when I am looking at a review and a piece of code that is taken out of context. #If I was more familiar with the code and had experience running the code and making changes to in on my local machine. Seeing changes to the functionality as I am changing the code would have helped.
ncsu77#It was provided though a medium that I knew and have used before and therefore felt comfortable with, so I could provide accurate information for myself.#There were a specific things that I wanted to test based on Java specific behaviors.#If I could see whole files, then I could get context for what was being changed. Some functions were hidden, so I could only assume that the code was being changed. For all I know, it would have done nothing. But since I couldn't see those functions, I had no way of knowing.
ncsu78#The short methods where I could trace it in my head were nice.#One of them was 200 lines long and I should've used an IDE for that one but I didn't think I'd have time for that.#A better and faster IDE than the one I currently use so I could more reliably use it in situations like this.
ncsu79#the code was short#understanding what qualified as changing the behavior of the code#give an example of what changes you should be allowed to merge and what ones you should request chagnes for 
ncsu80#I think the easiest part was when only a couple lines changed. Then I didn't have to worry about certain lines changing stuff further down.#Trying to read it was the most difficult part#Maybe a slightly better instructions.
ncsu81#I was already familiar with how PRs work, including leaving comments and approving changes, so I wasn't very afraid of making mistakes (although I did accidentally say approve changes one time when I meant to say request changes).#Trying to figure out what code changes. Some code changes seem redundant and very long, but it may not change the functionality.#Leaving comments in the code (as a programmer) would be helpful.
ncsu82#Some of the PRs were quite easy and straight forward#Some of the code I had difficulty understanding.#If I had another monitor.
ncsu83#Variable names and methods were easy to figure out the meaning of, because of intention based naming.#Reading all of the undocumented code, and having to manually figure out what the code was doing.#More documentation on the code and in code comments.
ncsu84#Some were easy to identify a value change#Sometimes there was so much code that needed to be reviewed it seemed as a jumble of code#Less jumbled code/shorter method parameters
ncsu85#The changes to the code behavior were obvious in some places.#Some of the code felt like it had unneccesary changes.#If I had knowledge of the project, or if I knew what the code was doing.
ncsu86#some of them were one line and super basic.#I didnt know what the code was SUPPOSED to do#Having comments for what the code does, or what the parameters are supposed to be
ncsu87#The logic changes was not heavy at all#Seconding guessing myself#Not sure
ncsu88#Identifying potential behavior changes#Tracing/evaluating convoluted paths and expressions to see if a bizarre change somehow didn't change the return value#Actually running tests on the code in an IDE for the more convoluted methods, like TCAS, so that I could test inputs without doing a lot of error-prone human math
ncsu89#Some of the files were relatively easy to understand #Limited time and not able to concentrate well. Seconding doubting myself. #More time and have knowledge before class of what we need to do 
ncsu90#Being able to quickly notice certain refactors of code in which are just changing the actual writing of the code and not the functionality.#The limited time, as well as many different code topics needed to be reviewed, if they all followed the same code goal, as if they were all apart of the same project it would have been more formatted and easier to determine.#Being able to test the code on a running machine, to see if multiple test values produce the same output or not.
ncsu91#Walking through the code and figuring out if values stayed the same.#Figuring out whether the change preserved behavior. Some of the changes seemed meaningless.#Working with others.
ncsu92#Using the split method to view the code side by side#It was difficult when a lot of variables were used at once. There was one PR that had a method taking in 13 parameters. I understood they were trying to draw out the code to separate private functions, but it was hard to make sure that no behavioral changes were made. #Maybe allowing for us to zoom out on the code because with the larger PRs it was hard to scroll up and down to make sure there was proper refactoring when similar code was now in different places. 
ncsu93#Reviewing the green and red lines.#Not really difficult.#More quiet.
ncsu94#The files contained a few changes on very specific lines as a result of which it was easy to consider the outcomes of the changes.#The requirements or the exact expectations of the code was not given so it was a bit hard to figure that out while evaluating the changes in the code. #Having the requirements or the exact expectations of the code or the snippet of the code.
ncsu95#The way GitHub provides the changes for you#Just having to think about it this early in the morning#nothing
ncsu96#Some code changes were pretty small and it was easy to figure out what was going (like basic if branch comparisons).#Understanding the context of the code and big variables used in some files.#If I was familiar with the code base beforehand it would have helped my code review
ncsu97#Using GitHub. GitHub is something I am familiar with so using it is easy.#No most of the code changes were minimal and easy to read.#A summary of what the intended purpose of the programs was.
ncsu98#The easy thing was there was some instances that was easy to identify. #The difficult was knowing what counts as refactoring and what doesn't count. #Honestly, I don't think I needed anything to help me code review. 
ncsu99#Submitting the Change request and submitting the merges.#Needed to go back and look at the entire file everytime to understand the review. Was not provided enough information from github in the split view to be able to know if the change was good or not. #The whole file being displayed so that I can see an overall view of the change. 
ncsu100#GitHub is nice with its highlighting.#Some of the changes seemed unnecessary. If there was justification/comments around the change, it would help to determine how to evaluate its effect.#Comments/unit test results
ncsu101#For the smaller files that were more math based, it was easy to analyze.#For larger files with more changes, it was harder to keep up with how exactly changes in some segments led to potential changes in orders.#Probably having my IDE open.
ncsu102#Some of the changes were obvious such as changing the return value from 0 to a variable which would have been 0. #I was not sure about some of the math functions and the recursion. It would have been helpful to have some background information. #If I was a developer working on the program, it would have been a lot easier to understand what was happening with the changes. I did not understand some of the return values and variables. 
ncsu103#Some changes were obvious#Not all changes were obvious, I had to go look at the entire file#Comments about the change
ncsu104#Having the split view on GitHub to see the changes clearly.#Not having context to what the code was doing.#Knowing context, having good documentation and how the files interact with each other.
ncsu105#Clicking merge and approve or not approving and closing.#Understanding what the code was doing and whether or not they affected the outcome of the code itself#Having a better understanding of each code before being assigned to complete this research.
ncsu106#There was one change that was simply an added tab. I found that easy to spot.#Calculating the possible outcomes based on the changes. #I am not sure. 
ncsu107#Sometimes the changes were very obvious, such as changing the inequality operator, as that would change the way the if/else statements would run#Some of the review included changes that looked very small but could change the behavior, so I would have to check to make sure the code didn't significantly alter anything#Reviewing with another person to compare thoughts and check each other's thinking
ncsu108#Github made it very easy by highlighting the code changes.#Lengthy functions were hard to read in order to check for consistency in refractoring.#Intentions of changing the code.
ncsu109#The fact that only 1 file needed to be reviewed for each PR was probably the easiest part. If there were more files, it would probably be more overwhelming#Having to mentally compile the code to evaluate the result was probably the most difficult part.#I think if I had more context on how the code would be used, I could maybe review the code more effectively.
ncsu110#The highlighting of changed code in the github files changes. #Not having access to the full code and functionality. #Having access to the full code to see functionality. 
ncsu111#Seeing the changes was easy for the most part except for that giant file.#The last code with a ton of changes was hard to look through.#Knowing what each java file did beforehand like a summary given by the developer.
ncsu112#The functions themselves were really easy, so it was easy to understand changes. In large codebases, I can imagine this being harder #Some of the wording could be better #Collapsable functionality in the github files changed area 
ncsu113#The code was easy to understand#The context of the code was unknown#having context of the code
ncsu114#GitHub clearly highlights where changes were made#There were no comments provided in the code to direct our understanding of the intended functionality.#Comments in the code
ncsu115#All the pull requests and everything was setup already beforehand and was a easy process to follow along. #Trying to understand follow the code and figure out what it was meant to do in the first place. #
ncsu116#It was easy to follow and easy to understand #Figuring out if the behavior changes were actually happening#Nothing I thought the experience went smoothly
ncsu117#Some actions clearly changed the behavior.#Understanding the original behavior of the code with no comments.#Comments on what the code was supposed to be doing.
ncsu118#yes it was easy#I didnt find any issues for this study#probably someone reviewing it with me  
ncsu119#Identifying what was altered between the code.#Understanding what the code's intent was.#Understanding the intent or objective behind each code or pull request.
ncsu120#Pull request titles and color highlights in the lines changed#Recursion is hard to run through the steps in my head#More comments throughout the code
ncsu121#Some of the code changes were obvious in how they would affect the function. #Figuring out how changes to math formulas and recursion affects the function. #Leveraging generative AI more effectively would help me perform code review more thoroughly. 
ncsu122#The GitHub interface is intuitive.#I second guess myself a lot before submitting a review because I don't want to be wrong.#Integrated IDE so I could like right click on functions to go directly to them.
ncsu123#Using split review in order to see the differences in the changes.#The limited context I was given with some of the changes.#More context on the methods that were being changed.
ncsu124#Most of the changes were simple math changes so I don't think I needed to consult google or any other sources, or at least I didn't feel like I needed to but depends how well I did.#I'm really tired right now, I stayed up too late last night. So i don't think i have the ability to fully think through some of the changes.#Being able to run tests on what i suspect might be values that result in a different outcome than before. If I think the code will give a new result I'd love to give it a quick test.
